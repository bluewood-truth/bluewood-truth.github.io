---
title: "알고리즘: 유니온 파인드(Union-Find)"
description: "유니온 파인드에 대해 공부하고 정리한 내용입니다."
comments: true
category: [Algorithm Studying]
tag: [Algorithm, Python]
---

# 유니온-파인드 (Union-Find)

**서로소 집합(disjoint-set)** 자료구조를 구현하기 위한 알고리즘이다. 서로소 집합 자료구조란 여러 서로소 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조를 말한다. 이를 이용해 두 원소가 같은 집합에 포함되는지를 확인할 수도 있어 최소 비용으로 모든 노드를 연결하는 그래프를 찾는 **크루스칼 알고리즘**에서 핵심적인 역할을 한다.

유니온-파인드의 연산은 다음과 같다.

- `find()`: 해당 집합의 대표값을 반환한다.
- `union()`: 두 집합을 하나의 집합으로 합친다.

예를 들어 1, 2, 3, 4, 5, 6 이 6개의 원소에 대해 생각해보자.

> (1) (2) (3) (4) (5) (6)

|    원소    |  1   |  2   |  3   |  4   |  5   |  6   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
| **대표값** |  1   |  2   |  3   |  4   |  5   |  6   |

최초에는 모든 원소가 대표값으로 자기 자신을 가리킨다. 즉, 크기가 1인 서로소 집합이 6개 존재한다.

> `union(1, 2)`
>
> (1, 2) (3) (4) (5) (6)

|    원소    |  1   |  2   |  3   |  4   |  5   |  6   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
| **대표값** |  1   |  1   |  3   |  4   |  5   |  6   |

원소 1, 2에 대해 `union()` 연산을 수행하면 두 집합이 합쳐지며 2는 대표값으로 1을 가리킨다. 대표값을 정하는 방법은 여러가지가 있지만, 여기서는 `union()` 시 먼저 온 값을 기준으로 한다.

> `union(2, 3)`
>
> (1, 2, 3) (4) (5) (6)

|    원소    |  1   |  2   |  3   |  4   |  5   |  6   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
| **대표값** |  1   |  1   |  1   |  4   |  5   |  6   |

원소 2, 3에 대해 `union()`을 수행했고 3은 대표값으로 1을 가리킨다. 2가 아닌 1을 가리키는 이유는, `union()`시에 `find()` 연산을 이용해 최종적인 대표값을 찾아 계산하기 때문이다. 즉 2의 대표값인 1을 3의 대표값으로 삼는다.

> `union(6, 5)`
>
> `union(5, 4)`
>
> (1, 2, 3) (4, 5, 6)

|    원소    |  1   |  2   |  3   |  4   |  5   |  6   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
| **대표값** |  1   |  1   |  1   |  6   |  6   |  6   |

다시 `union()` 연산을 이용해 이번엔 4, 5, 6을 한 집합으로 만들었다.

> `union(5, 2)`
>
> (1, 2, 3, 4, 5, 6)

|    원소    |  1   |  2   |  3   |  4   |  5   |  6   |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |
| **대표값** |  6   |  1   |  1   |  6   |  6   |  6   |

원소 5, 2에 대해 `union()` 연산을 수행했고, 결과 모든 원소가 하나의 집합으로 합쳐졌다.

여기서 원소 1의 대표값이 6으로 변경된 이유는, 앞서 말했듯 `union()` 시에는 대표값을 찾아서 계산하기 때문이다. 5의 대표값인 원소6을 찾고, 2의 대표값인 원소 1을 찾은 후, 1의 대표값을 6으로 변경한 것이다.

서로 같은 집합인지 판별할 때는 `find()` 연산을 이용해 최종적인 대표값을 비교한다. `find()`는 재귀적으로 정의되므로 같은 집합이라면 결국 같은 값을 가리키게 된다.

```python
class disjoint_set:
    def __init__(self, array:list)
        self.data = {}
        for v in array:
            self.data[v] = v # 모든 원소의 대표값을 자기 자신으로 초기화
    
    def find(self, x):
        if self.data[x] == x:
            return x
        
        return self.find(self.data[x])
    
    def union(self, x, y):
        x_root = self.find(x)
        y_root = self.find(y)
        self.data[y_root] = x_root
```

```python
ds = disjoint_set([1,2,3,4,5,6])

ds.union(1, 2)
ds.union(2, 3)
ds.union(6, 5)
ds.union(4, 6)

print(ds.data)
print("1과 3은 같은 집합인가?", ds.find(1) == ds.find(3))
print("5와 6은 같은 집합인가?", ds.find(5) == ds.find(6))
print("1과 6은 같은 집합인가?", ds.find(1) == ds.find(6))

ds.union(3, 4)
print(ds.data)
print("1과 6은 같은 집합인가?", ds.find(1) == ds.find(6))

# <출력>
# {1: 1, 2: 1, 3: 1, 4: 4, 5: 6, 6: 4}
# 1과 3은 같은 집합인가? True
# 5와 6은 같은 집합인가? True
# 1과 6은 같은 집합인가? False
# {1: 1, 2: 1, 3: 1, 4: 1, 5: 6, 6: 4}
# 1과 6은 같은 집합인가? True
```

